---
title: "EnkaManager"
description: Class for fetching EnkaData from enka.network
badge: class
---

import { TypeLink, MethodAccordion, TypeTableByBadge, Md } from '@/components/api'
import { Callout } from 'fumadocs-ui/components/callout'


extends <span><span className="text-[#0550ae] dark:text-[#79c0ff]">PromiseEventEmitter</span>&lt;<span key="a0"><span className="text-[#0550ae] dark:text-[#79c0ff]">EnkaManagerEventMap</span></span><span key="a1">, <TypeLink type="EnkaManagerEvents" /></span>&gt;</span>


---

## Methods


<MethodAccordion
  name="addListener"
  returnType={<span className="text-[#0550ae] dark:text-[#79c0ff]">this</span>}
  description={<><Md>{`Alias for \`emitter.on(eventName, listener)\`.`}</Md></>}
  parameters={[{ name: "eventName", typeJsx: <span><span key="u0"><span className="text-[#0550ae] dark:text-[#79c0ff]">"GET_NEW_ENKA_DATA"</span></span><span key="u1"> | <TypeLink type="EnkaManagerEvents" /></span><span key="u2"> | <span className="text-[#0550ae] dark:text-[#79c0ff]">K</span></span></span>, description: <Md>{`the name of the event.`}</Md>, optional: false, defaultValue: undefined }, { name: "listener", typeJsx: <span className="text-[#0550ae] dark:text-[#79c0ff]">unknown</span>, description: <Md>{`the callback function. (supports async)`}</Md>, optional: false, defaultValue: undefined }]}
  
  
  isAsync={false}
  isStatic={false}
  isAbstract={false}
/>


<MethodAccordion
  name="clearCacheOverNextShowCaseDate"
  returnType={<span className="text-[#0550ae] dark:text-[#79c0ff]">void</span>}
  description={<><Md>{`Clear cache over nextShowCaseDate`}</Md></>}
  parameters={[]}
  
  
  isAsync={false}
  isStatic={false}
  isAbstract={false}
/>


<MethodAccordion
  name="fetchAll"
  returnType={<span><span className="text-[#0550ae] dark:text-[#79c0ff]">Promise</span>&lt;<span key="a0"><TypeLink type="EnkaData" /></span>&gt;</span>}
  description={<><Md>{`Fetch All from enka.network`}</Md><Callout type="info"><Md>{`The data fetched by this method is stored as a temporary cache.    The storage period depends on ttl.`}</Md></Callout></>}
  parameters={[{ name: "uid", typeJsx: <span className="text-[#0550ae] dark:text-[#79c0ff]">number</span>, description: <Md>{`UID`}</Md>, optional: false, defaultValue: undefined }, { name: "fetchOption", typeJsx: <span className="text-[#0550ae] dark:text-[#79c0ff]">RequestInit</span>, description: <Md>{`fetch option`}</Md>, optional: true, defaultValue: undefined }]}
  returns={<Md>{`enka data`}</Md>}
  example={`const enkaManager = new EnkaManager()
const data = await enkaManager.fetchAll(123456789)
console.log(data.playerDetail.nickname)`}
  isAsync={true}
  isStatic={false}
  isAbstract={false}
/>


<MethodAccordion
  name="fetchAllStatus"
  returnType={<span><span className="text-[#0550ae] dark:text-[#79c0ff]">Promise</span>&lt;<span key="a0"><span><span className="text-[#0550ae] dark:text-[#79c0ff]">Record</span>&lt;<span key="a0"><span className="text-[#0550ae] dark:text-[#79c0ff]">string</span></span><span key="a1">, <TypeLink type="APIEnkaStatus" /></span>&gt;</span></span>&gt;</span>}
  description={<><Md>{`Fetch Status from 1 hour ago to now`}</Md></>}
  parameters={[{ name: "fetchOption", typeJsx: <span className="text-[#0550ae] dark:text-[#79c0ff]">RequestInit</span>, description: <Md>{`fetch option`}</Md>, optional: true, defaultValue: undefined }]}
  returns={<Md>{`status from 1 hour ago to now`}</Md>}
  
  isAsync={true}
  isStatic={false}
  isAbstract={false}
/>


<MethodAccordion
  name="fetchEnkaAccount"
  returnType={<span><span className="text-[#0550ae] dark:text-[#79c0ff]">Promise</span>&lt;<span key="a0"><TypeLink type="EnkaAccount" /></span>&gt;</span>}
  description={<><Md>{`Fetch EnkaAccount from enka.network`}</Md><Callout type="info"><Md>{`Data fetched by this method is not stored as a temporary cache.`}</Md></Callout></>}
  parameters={[{ name: "username", typeJsx: <span className="text-[#0550ae] dark:text-[#79c0ff]">string</span>, description: <Md>{`enka account username`}</Md>, optional: false, defaultValue: undefined }, { name: "fetchOption", typeJsx: <span className="text-[#0550ae] dark:text-[#79c0ff]">RequestInit</span>, description: <Md>{`fetch option`}</Md>, optional: true, defaultValue: undefined }]}
  returns={<Md>{`enka account`}</Md>}
  example={`const enkaManager = new EnkaManager()
const account = await enkaManager.fetchEnkaAccount('username')
console.log(account.nickname)`}
  isAsync={true}
  isStatic={false}
  isAbstract={false}
/>


<MethodAccordion
  name="fetchGenshinAccounts"
  returnType={<span><span className="text-[#0550ae] dark:text-[#79c0ff]">Promise</span>&lt;<span key="a0"><TypeLink type="GenshinAccount" isArray /></span>&gt;</span>}
  description={<><Md>{`Fetch GenshinAccounts from enka.network`}</Md><Callout type="info"><Md>{`Data fetched by this method is not stored as a temporary cache.`}</Md></Callout></>}
  parameters={[{ name: "username", typeJsx: <span className="text-[#0550ae] dark:text-[#79c0ff]">string</span>, description: <Md>{`enka account username`}</Md>, optional: false, defaultValue: undefined }, { name: "fetchOption", typeJsx: <span className="text-[#0550ae] dark:text-[#79c0ff]">RequestInit</span>, description: <Md>{`fetch option`}</Md>, optional: true, defaultValue: undefined }]}
  returns={<Md>{`genshin accounts`}</Md>}
  example={`const enkaManager = new EnkaManager()
const accounts = await enkaManager.fetchGenshinAccounts('username')
console.log(accounts[0].uid)`}
  isAsync={true}
  isStatic={false}
  isAbstract={false}
/>


<MethodAccordion
  name="fetchNowStatus"
  returnType={<span><span className="text-[#0550ae] dark:text-[#79c0ff]">Promise</span>&lt;<span key="a0"><TypeLink type="APIEnkaStatus" /></span>&gt;</span>}
  description={<><Md>{`Fetch now Status`}</Md></>}
  parameters={[{ name: "fetchOption", typeJsx: <span className="text-[#0550ae] dark:text-[#79c0ff]">RequestInit</span>, description: <Md>{`fetch option`}</Md>, optional: true, defaultValue: undefined }]}
  returns={<Md>{`now status`}</Md>}
  
  isAsync={true}
  isStatic={false}
  isAbstract={false}
/>


<MethodAccordion
  name="fetchPlayerDetail"
  returnType={<span><span className="text-[#0550ae] dark:text-[#79c0ff]">Promise</span>&lt;<span key="a0"><TypeLink type="PlayerDetail" /></span>&gt;</span>}
  description={<><Md>{`Fetch PlayerDetail from enka.network`}</Md><Callout type="info"><Md>{`The data fetched by this method is stored as a temporary cache.    The storage period depends on ttl.`}</Md></Callout></>}
  parameters={[{ name: "uid", typeJsx: <span className="text-[#0550ae] dark:text-[#79c0ff]">number</span>, description: <Md>{`UID`}</Md>, optional: false, defaultValue: undefined }, { name: "fetchOption", typeJsx: <span className="text-[#0550ae] dark:text-[#79c0ff]">RequestInit</span>, description: <Md>{`fetch option`}</Md>, optional: true, defaultValue: undefined }]}
  returns={<Md>{`player detail`}</Md>}
  example={`const enkaManager = new EnkaManager()
const playerDetail = await enkaManager.fetchPlayerDetail(123456789)
console.log(playerDetail.nickname)`}
  isAsync={true}
  isStatic={false}
  isAbstract={false}
/>


<MethodAccordion
  name="off"
  returnType={<span className="text-[#0550ae] dark:text-[#79c0ff]">this</span>}
  description={<><Md>{`Alias for \`emitter.removeListener()\`.`}</Md></>}
  parameters={[{ name: "eventName", typeJsx: <span><span key="u0"><span className="text-[#0550ae] dark:text-[#79c0ff]">"GET_NEW_ENKA_DATA"</span></span><span key="u1"> | <TypeLink type="EnkaManagerEvents" /></span><span key="u2"> | <span className="text-[#0550ae] dark:text-[#79c0ff]">K</span></span></span>, description: <Md>{`the name of the event.`}</Md>, optional: false, defaultValue: undefined }, { name: "listener", typeJsx: <span className="text-[#0550ae] dark:text-[#79c0ff]">unknown</span>, description: <Md>{`the callback function. (supports async)`}</Md>, optional: false, defaultValue: undefined }]}
  
  
  isAsync={false}
  isStatic={false}
  isAbstract={false}
/>


<MethodAccordion
  name="on"
  returnType={<span className="text-[#0550ae] dark:text-[#79c0ff]">this</span>}
  description={<><Md>{`Adds the \`listener\` function to the end of the listeners array for the event named \`eventName\`. No checks are made to see if the \`listener\` has already been added. Multiple calls passing the same combination of \`eventName\`and \`listener\` will result in the \`listener\` being added, and called, multiple times.`}</Md></>}
  parameters={[{ name: "eventName", typeJsx: <span><span key="u0"><span className="text-[#0550ae] dark:text-[#79c0ff]">"GET_NEW_ENKA_DATA"</span></span><span key="u1"> | <TypeLink type="EnkaManagerEvents" /></span><span key="u2"> | <span className="text-[#0550ae] dark:text-[#79c0ff]">K</span></span></span>, description: <Md>{`the name of the event.`}</Md>, optional: false, defaultValue: undefined }, { name: "listener", typeJsx: <span className="text-[#0550ae] dark:text-[#79c0ff]">unknown</span>, description: <Md>{`the callback function. (supports async)`}</Md>, optional: false, defaultValue: undefined }]}
  
  
  isAsync={false}
  isStatic={false}
  isAbstract={false}
/>


<MethodAccordion
  name="once"
  returnType={<span className="text-[#0550ae] dark:text-[#79c0ff]">this</span>}
  description={<><Md>{`Adds a **one-time**\`listener\` function for the event named \`eventName\`. The next time \`eventName\` is triggered, this listener is removed and then invoked.`}</Md></>}
  parameters={[{ name: "eventName", typeJsx: <span><span key="u0"><span className="text-[#0550ae] dark:text-[#79c0ff]">"GET_NEW_ENKA_DATA"</span></span><span key="u1"> | <TypeLink type="EnkaManagerEvents" /></span><span key="u2"> | <span className="text-[#0550ae] dark:text-[#79c0ff]">K</span></span></span>, description: <Md>{`the name of the event.`}</Md>, optional: false, defaultValue: undefined }, { name: "listener", typeJsx: <span className="text-[#0550ae] dark:text-[#79c0ff]">unknown</span>, description: <Md>{`the callback function. (supports async)`}</Md>, optional: false, defaultValue: undefined }]}
  
  
  isAsync={false}
  isStatic={false}
  isAbstract={false}
/>


<MethodAccordion
  name="removeAllListeners"
  returnType={<span className="text-[#0550ae] dark:text-[#79c0ff]">this</span>}
  description={<><Md>{`Removes all listeners, or those of the specified \`eventName\`.`}</Md></>}
  parameters={[{ name: "event", typeJsx: <span><span key="u0"><span className="text-[#0550ae] dark:text-[#79c0ff]">"GET_NEW_ENKA_DATA"</span></span><span key="u1"> | <TypeLink type="EnkaManagerEvents" /></span><span key="u2"> | <span className="text-[#0550ae] dark:text-[#79c0ff]">K</span></span></span>, description: <Md>{`the name of the event.`}</Md>, optional: true, defaultValue: undefined }]}
  
  
  isAsync={false}
  isStatic={false}
  isAbstract={false}
/>


<MethodAccordion
  name="removeListener"
  returnType={<span className="text-[#0550ae] dark:text-[#79c0ff]">this</span>}
  description={<><Md>{`Removes the specified \`listener\` from the listener array for the event named\`eventName\`.`}</Md></>}
  parameters={[{ name: "eventName", typeJsx: <span><span key="u0"><span className="text-[#0550ae] dark:text-[#79c0ff]">"GET_NEW_ENKA_DATA"</span></span><span key="u1"> | <TypeLink type="EnkaManagerEvents" /></span><span key="u2"> | <span className="text-[#0550ae] dark:text-[#79c0ff]">K</span></span></span>, description: <Md>{`the name of the event.`}</Md>, optional: false, defaultValue: undefined }, { name: "listener", typeJsx: <span className="text-[#0550ae] dark:text-[#79c0ff]">unknown</span>, description: <Md>{`the callback function. (supports async)`}</Md>, optional: false, defaultValue: undefined }]}
  
  
  isAsync={false}
  isStatic={false}
  isAbstract={false}
/>
